%

\documentclass[10pt]{article}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{fullpage,multicol}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsmath,amscd,amssymb,url}
\usepackage[spanish]{babel}

\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Ot}[1]{O\left(#1\right)}

% ----------------------------------------------------------------
\vfuzz2pt % Don't report over-full v-boxes if over-edge is small
\hfuzz2pt % Don't report over-full h-boxes if over-edge is small
% ----------------------------------------------------------------

% remove space in enumeration
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Enumerate and Itemize modifications
\usepackage{enumitem}
\setlist{topsep=0pt}%,noitemsep} %\setitemize[1]{label=$\circ$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\hyphenation{data-base}
\setlength{\parindent}{0em}
\clubpenalty = 10000
\widowpenalty = 10000
%\parindent=0cm
\parskip=2mm


\parindent=0in % no indentation
\setlength{\parskip}{5pt} % space between paragraphs


\title{Proyecto 1\\ {\Large Análisis de Algoritmos}\\ {\Large Primer Semestre 2024,} {\large Prof. Cecilia Hernández}}
\date{}
\author{Melissa Muñoz \& Joaquín León}

\begin{document}


\maketitle

 {\bf  Fecha Inicio: Jueves 4 de Abril 2024. }
 
 {\bf Fecha Entrega: Lunes 22 de Abril 2024 (23:59 hrs). }
%

% ----------------------------------------------------------------
%\vspace{-1cm}
%\section{Ejercicios}

\begin{enumerate}
 \item \textbf{[5 puntos]}
Determine justificadamente si las siguientes afirmaciones son verdaderas o falsas. En caso de resultar verdadera, muestre los valores de las constantes $c,c_1,c_2$ y $n_0$ según corresponda.
\begin{enumerate}
  \item $n^2/\log(n^{20})$ es $o(n^2)$
  \item $\ln(n)+\sqrt{n}$ es $\Theta(\sqrt{n})$
  \item $2\sum_{i=1}^n i$ es $\Theta(n^2)$
  \item $2^n+4^n$ es $O(2^n)$.
  \item $2^n$ es $O(n^2)$.
\end{enumerate}


\item \textbf{[7 puntos]}  Ordene de menor a mayor orden asintótico las siguientes funciones. Justifique.

\begin{itemize}
  \item $(10^7)^{120!}$ \--- Equivalente a $O(1)$

  \item $\log \log n^3$ \--- Está entre $O(1)$ y $O(log(n)$
  \item $\log^2(n)	$   \--- Mayor a $O(log(n))$
  \item $\dfrac{3}{2}n$ \--- Equivalente a $O(n)$
  \item $n^2\log^2(n)$  \--- Mayor a $O(nlog(n))$
  \item $2^n$ 					\--- Exponencial
  \item $n!$            \--- Equivalente a $O(n!)$
\end{itemize}

\item \textbf{[4 puntos]}  Para cada una de las siguientes funciones, encuentre un $c>0$ y un $n_0\in\N$ que muestre que $f(n) \in \Ot{g(n)}$. Explique por qué tales valores funcionan bien.

\begin{enumerate}
  \item $f(n) = \sqrt{n^5}+4n^{10}+n\log(5) $, $g(n) = 10n^{10}$
  \item $f(n) = \sqrt{\log(n)n}+n^2$, $g(n) = (n\log(n))^2$
\end{enumerate} 


\item \textbf{[6 puntos]}  Resuelva las siguientes recurrencias.
\begin{enumerate}
  \item $T(n) = 12T\left(n/10\right) + n^{1/c},$ $c>1$.
  \item $T(n) = 3T\left(\sqrt[3]{n}\right) + c\log n,$ $c>0$.
  %[\textbf{REVISAR}: O poner sólo $\Ot{\log n}$]
\end{enumerate}

\item \textbf{[6 puntos]} Construya los árboles recursivos para las siguientes recurrencias, estime la solución de la recurrencia y luego demuestre por substitución.

\begin{enumerate}
  \item $T(n) = 2T(n/4) + c\sqrt{n}$, con $T(1) = 1$.
  \item $T(n) = T(n-1) + n$
\end{enumerate}

\item \textbf{[5 puntos]} Use substitución para demostrar las siguientes recurrencias. Note que debe aplicar las definiciones asintóticas. 

\begin{enumerate}
  \item $T(n) = T(n-1) + log(n)$ su solución es $T(n) = \Theta(n\log(n))$
  \item $T(n) = T(n/2) + T(n/4) + T(n/16) +cn$ su solución es $T(n) = \Theta(n)$
\end{enumerate}


\item \textbf{[6 puntos]} Proporcione un análisis asintótico de peor caso en notación $\Ot{}$ para el tiempo de ejecución de los siguientes fragmentos de programa.

\begin{scriptsize}
\begin{tabular}{ll}
\begin{minipage}{3in}
\begin{verbatim}

(a) ============================================================================================================

for( int i = 1; i <= n; i *= 2 ) {         // O(log n)                                         // O((n / 2) log n + (n^2 / 2) log n)
  for( int j = 1; j < n; j += 2 ) {        // O(n/2)           // O((n / 2) log n + (n^2 / 2)) //
    f();                                   // O(log n)         //                              //
    for( int k = 1; k < 3; k *= 2 ) {      // O(1)     // O(n) //                              //
      g();                                 // O(n)     //      //                              //
    }                                                  //      //                              //
  }                                                            //                              //
}                                                                                              //

O(n^2 log n)

(b) ============================================================================================================

for( int i = 1; i <= n; i *= 2 ) {         // O(log n)                                   // O(2 n^2 log^2 n + n log n)
  for( int j = 1; j < n; j *= 2 ) {        // O(log n)                 // O(2 n^2 log n) //
    for( int k = 1; k < n; k += 1 ) {      // O(n)         // O(2 n^2) //                //
      f();                                 // O(n)         //          //                //
      for( int l = 1; l < 100; k += 1 ) {  // O(1) // O(n) //          //                //
        g();                               // O(n) //      //          //                //
      }                                            //      //          //                //
    }                                                      //          //                //
  }                                                                    //                //
  h();                                     // O(n)                                       //
}

O(n^2 log^2 n)

(c) ============================================================================================================

void f(int n) {
  if( n > 1 ) {                                                          // O((4 n^2) / 3)
    f(n/3);                                // O((n/3)^2) // O((n^2) / 3) //
    f(n/3);                                // O((n/3)^2) //              //
    f(n/3);                                // O((n/3)^2) //              //
    for ( int i = 0; i < n; i++ ) {        // O(n)       // O(n^2)       //
      ProcesaA();                          // O(n)       //              //
    }                                                    //              //
  } else {                                                               //
      ProcesaB();                          // O(1)                       //
  }                                                                      //
}

O(n^2)
\end{verbatim}

\end{minipage}
\end{tabular}
\end{scriptsize}

\clearpage

\item \textbf{[6 puntos]}Determine qué realiza el siguiente algoritmo, demuestre que es correcto y determine su complejidad asintótica.

\begin{scriptsize}
\begin{verbatim}
int F(int* A, int n, float x){
  p=0;
  for i=0 to n{
    p = A[n-i] + x*p;
  }
  return p;
}
\end{verbatim}
\end{scriptsize}

\textit{Indicación:} El arreglo $A$ de tamaño $n$ representa los coeficientes de un polinomio $p(x)=\sum_{i=0}^na_ix^i$.

\item \textbf{[7 puntos]} Considere un conjunto de puntos tridimensionales con coordenadas reales con signo. Reporte la distancia mínima entre dos puntos. Para ello utilizaremos la distancia euclidiana entre dos puntos. Dados dos puntos $p_1(x_1,y_1,z_1)$ y $p_2(x_2,y_2,z_2)$, el cálculo de la distancia euclidiana es la siguiente:

\begin{equation*}
    d_{p_1,p_2} = \sqrt{(x_2-x_1)^2+(y_2-y_1)^2+(z_2-z_1)^2}
\end{equation*}

\begin{enumerate}
    \item Escriba un pseudo código para un algoritmo secuencial que resuelva el problema.
    \item Diseñe un algoritmo basado en dividir para conquistar que resuelva el problema en escriba su pseudo código.
    \item Demuestre correctitud de sus algoritmo y realice los análisis de tiempo de ejecución.
\end{enumerate}


\item \textbf{[8 puntos]} Considerando el problema anterior, modifique los algoritmos propuestos para que reporte todos los pares de puntos cuya distancia sea menor o igual a una distancia $d$.

\begin{enumerate}
    \item Modifique los dos algoritmos propuestos para el problema anterior para que resuelvan esta nueva versión. Escriba los pseudocódigos para los nuevos problemas.
    \item Explique los cambios realizados a la hora de adaptar los algoritmos.
    \item Demuestre correctitud de sus algoritmo y realice los análisis de tiempo de ejecución.
    \item Implemente sus algoritmos usando C/C++ definiendo una función para cada uno.
    \item Realice análisis experimental para lo cual se pide que construya un gráfico que muestre como varían los tiempos de ejecución en nanosegundos variando el tamaño de la entrada ($n$).
\end{enumerate}

%\item{[1.5 puntos]} Considere un arreglo $A$ ordenado cuyo largo es infinito. El arreglo $A$ está ordenado y se sabe que los primeros $n$ elementos tienen un valor finito y los siguientes son valores tienen el valor infinito. Diseñe un algoritmo en $O(log(n))$ que permita determinar si un elemento $a$ se encuentra o no en $A$. Note que el valor de $n$ es desconocido. Además argumente la correctitud de su algoritmo.


%Idea: Dado un árbol de n vértices que represente un ordenamiento (tipo, el nodo hijo de la izq es menor y el de la derecha, mayor). Se dice\\

%Armar árbol cartesiano $T(n) = 2T(n/2)+n$.\\

%Tiling problem para un cubo de lado $n=2^k$, con $k\in\N$.

% \item{[15 puntos]} Se quiere construir un cubo de lado $n=2^k$ unidades, con $k\in\N$, utilizando sólo un tipo de pieza especial. Esta pieza especial consiste en un cubo de lado 2 unidades al que le falta una sola esquina. Un ingeniero asegura que es imposible a menos que esté permitido que haya un espacio cúbico vacío de lado 1 unidad. Diseñe un algoritmo que, dado el lado del cubo $n=2^k$ y la posición donde quedará el espacio vacío, determine una manera de juntar las piezas especiales para armar el cubo de $n^3-1$ unidades cuadradas.

%\item{[1.5 puntos]} Se desea resolver el problema de encontrar el elemento mayoritario en un arreglo $A$ de largo $n$ si es que existe. En caso de no existir el algoritmo debe retornar que no existe. Ejemplo, si $A = [1,2,1,3,1,2,1]$, con $n=7$ el elemento mayoritario es el 1 porque aparece 4 veces y $4 > 7/2$. Diseñe los algoritmos siguientes usando dividir para conquistar, impleméntelos, determine sus recurrencias y obtenga soluciones. Además construya un gráfico con los tiempos de ejecución incrementando el número el valor de $n$ en potencias de 2.

%\begin{enumerate}
%  \item Diseñe e implemente un algoritmo que sea $O(n^2)$.
%  \item Diseñe e implemente un algoritmo que sea $O(n\log(n)$.
%  \item Diseñe e implemente un algoritmo que sea $O(n)$.
%\end{enumerate}

\input{cheatsheet}

\end{enumerate}

% ----------------------------------------------------------------
\end{document}
% ----------------------------------------------------------------
