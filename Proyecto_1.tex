%

\documentclass[10pt]{article}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{fullpage,multicol}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsmath,amscd,amssymb,url}
\usepackage[spanish]{babel}

\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Ot}[1]{O\left(#1\right)}

% ----------------------------------------------------------------
\vfuzz2pt % Don't report over-full v-boxes if over-edge is small
\hfuzz2pt % Don't report over-full h-boxes if over-edge is small
% ----------------------------------------------------------------

% remove space in enumeration
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Enumerate and Itemize modifications
\usepackage{enumitem}
\setlist{topsep=0pt}%,noitemsep} %\setitemize[1]{label=$\circ$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\hyphenation{data-base}
\setlength{\parindent}{0em}
\clubpenalty = 10000
\widowpenalty = 10000
%\parindent=0cm
\parskip=2mm


\parindent=0in % no indentation
\setlength{\parskip}{5pt} % space between paragraphs


\title{Proyecto 1\\ {\Large Análisis de Algoritmos}\\ {\Large Primer Semestre 2024,} {\large Prof. Cecilia Hernández}}
\date{}
\author{Melissa Muñoz \& Joaquín León}

\begin{document}


\maketitle

 {\bf  Fecha Inicio: Jueves 4 de Abril 2024. }
 
 {\bf Fecha Entrega: Lunes 22 de Abril 2024 (23:59 hrs). }
%

% ----------------------------------------------------------------
%\vspace{-1cm}
%\section{Ejercicios}

\begin{enumerate}
 \item \textbf{[5 puntos]}
Determine justificadamente si las siguientes afirmaciones son verdaderas o falsas. En caso de resultar verdadera, muestre los valores de las constantes $c,c_1,c_2$ y $n_0$ según corresponda.
\begin{enumerate}
  \item $n^2/\log(n^{20})$ es $o(n^2)$
  \item $\ln(n)+\sqrt{n}$ es $\Theta(\sqrt{n})$
  \item $2\sum_{i=1}^n i$ es $\Theta(n^2)$
  \item $2^n+4^n$ es $O(2^n)$.
  \item $2^n$ es $O(n^2)$.
\end{enumerate}


\item \textbf{[7 puntos]}  Ordene de menor a mayor orden asintótico las siguientes funciones. Justifique.

\begin{itemize}
  \item $(10^7)^{120!}$ \--- Equivalente a $O(1)$

  \item $\log \log n^3$ \--- Está entre $O(1)$ y $O(log(n))$
  \item $\log^2(n)	$   \--- Mayor a $O(log(n))$
  \item $\dfrac{3}{2}n$ \--- Equivalente a $O(n)$
  \item $n^2\log^2(n)$  \--- Mayor a $O(nlog(n))$
  \item $2^n$ 					\--- Exponencial
  \item $n!$            \--- Equivalente a $O(n!)$
\end{itemize}

\item \textbf{[4 puntos]}  Para cada una de las siguientes funciones, encuentre un $c>0$ y un $n_0\in\N$ que muestre que $f(n) \in \Ot{g(n)}$. Explique por qué tales valores funcionan bien.

\begin{enumerate}
  \item $f(n) = \sqrt{n^5}+4n^{10}+n\log(5) $, $g(n) = 10n^{10}$
  \item $f(n) = \sqrt{\log(n)n}+n^2$, $g(n) = (n\log(n))^2$
\end{enumerate} 


\item \textbf{[6 puntos]}  Resuelva las siguientes recurrencias.
\begin{enumerate}
  \item $T(n) = 12T\left(n/10\right) + n^{1/c},$ $c>1$.
  \item $T(n) = 3T\left(\sqrt[3]{n}\right) + c\log n,$ $c>0$.
  %[\textbf{REVISAR}: O poner sólo $\Ot{\log n}$]
\end{enumerate}

\item \textbf{[6 puntos]} Construya los árboles recursivos para las siguientes recurrencias, estime la solución de la recurrencia y luego demuestre por substitución.

\begin{enumerate}
  \item $T(n) = 2T(n/4) + c\sqrt{n}$, con $T(1) = 1$.
  \item $T(n) = T(n-1) + n$
\end{enumerate}

\item \textbf{[5 puntos]} Use substitución para demostrar las siguientes recurrencias. Note que debe aplicar las definiciones asintóticas. 

\begin{enumerate}
  \item $T(n) = T(n-1) + log(n)$ su solución es $T(n) = \Theta(n\log(n))$

	\begin{align*}
		T(n) &= T(n - 1) + \log(n)											\\
		T(n) &= T(n - 2) + \log(n) + \log(n)						\\
		T(n) &= T(n - 3) + \log(n) + \log(n) + \log(n)	\\
		     &  \vdots																\\
		T(n) &= T(n - n) + n\log(n)										\\
		T(n) &= C + n \log(n)
	\end{align*}
	Donde $C$ es la complejidad de $T(0)$.

	Luego, $T(n)=\Theta(f(n)) \Leftrightarrow{} \exists c_1, c_2 \in \Re \backslash c_1 f(n) \leq T(n) \leq c_2 f(n), \forall n \geq n_0 $. Pero como la expansión de $T(n)=n\log(n)$ es igual al $f(n)=n\log(n)$ que se usa para acotarla, $T(n)=\Theta(n\log(n))$ se cumple $\forall c_1, c_2, n_0 \in \Re, c_1 < 1, c_2 > 1, n_0 \geq 0$. $\therefore$ la cota dada es cierta. 

  \item $T(n) = T(n/2) + T(n/4) + T(n/16) +cn$ su solución es $T(n) = \Theta(n)$
  
  \begin{align*}
  	T(n) &= T(\frac{n}{2}) + T(\frac{n}{4}) + T(\frac{n}{16}) \\
  	T(n) &= T(\frac{n}{4}) + T(\frac{n}{8}) + T(\frac{n}{32}) + T(\frac{n}{4}) + T(\frac{n}{16}) &= 2T(\frac{n}{4}) + T(\frac{n}{8}) + T(\frac{n}{16}) + T(\frac{n}{32}) \\
  	T(n) &= 2T(\frac{n}{8}) + 2T(\frac{n}{16}) + 2T(\frac{n}{64}) + T(\frac{n}{8}) + T(\frac{n}{16}) + T(\frac{n}{32}) &= 3T(\frac{n}{8}) + 3T(\frac{n}{16}) + 3T(\frac{n}{64}) + T(\frac{n}{32}) \\
  	T(n) &= 3T(\frac{n}{16}) + 3T(\frac{n}{32})
  	\vdots \\
  	T(n) = 
  \end{align*}
\end{enumerate}


\item \textbf{[6 puntos]} Proporcione un análisis asintótico de peor caso en notación $O(t)$ para el tiempo de ejecución de los siguientes fragmentos de programa.

\begin{verbatim}

(a) =======================================================

for( int i = 1; i <= n; i *= 2 ) {         // O(log n)
  for( int j = 1; j < n; j += 2 ) {        // O(n/2)
    f();                                   // O(log n)
    for( int k = 1; k < 3; k *= 2 ) {      // O(1)
      g();                                 // O(n)
    }
  }
}
\end{verbatim}

Luego, multiplico los loops $\log n * \frac{n}{2} * (\log n + 1 * n) = \frac{\log^2 n + n^2\log n}{2}$. Pero para los propósitos del análisis asintótico, me deshago del denominador, y en caso de una suma, me quedo con el mayor sumando de los dos. En éste caso, $n^2 \log n$, ya que $\forall n \geq 1$, $n > \log n \Rightarrow n^2 > \log^2 n $, $\therefore$ la complejidad temporal es $O(n^2 \log n)$.

\begin{verbatim}
(b) =======================================================

for( int i = 1; i <= n; i *= 2 ) {         // O(log n)
  for( int j = 1; j < n; j *= 2 ) {        // O(log n)
    for( int k = 1; k < n; k += 1 ) {      // O(n)
      f();                                 // O(n)
      for( int l = 1; l < 100; k += 1 ) {  // O(1)
        g();                               // O(n)
      }
    }
  }
  h();                                     // O(n)
}
\end{verbatim}

Luego multiplico los loops $\log n * \log n * n * (n + 1 * n) = n \log^2 n + n^2 \log^2 n$. Me deshago del sumando menor, que es $n \log^2 n$ ya que $\forall n > 1, n^2 > n$. Luego me queda que la complejidad final del algoritmo es $O(n^2 \log^2 n)$

\begin{verbatim}
(c) =======================================================

void f(int n) {
  if( n > 1 ) {
    f(n/3);
    f(n/3);
    f(n/3);
    for ( int i = 0; i < n; i++ ) {
      ProcesaA(); // O(n)
    }
  } else {
      ProcesaB(); // O(1)
  }
}
\end{verbatim}

El análisis equivalente es $T(n) = 3T(\frac{n}{3})+n^2$. Luego puedo usar el método de sustitución:

\begin{align*}
	T(n) &= 3T(\frac{n}{3}) + n^2 \\
	T(n) &= 3(3T(\frac{n}{3^2}) + \frac{n^2}{3^2}) + \frac{n^2}{3^0} \\
	T(n) &= 3^2(3T(\frac{n}{3^3}) + \frac{n^2}{3^4}) + \frac{n^2}{3^1} + \frac{n^2}{3^0} \\
	T(n) &= 3^3(3T(\frac{n}{3^4}) + \frac{n^2}{3^6}) + \frac{n^2}{3^2} + \frac{n^2}{3^1} + \frac{n^2}{3^0} \\
	\vdots \\
	T(n) &= 3^kT(\frac{n}{3^k})+n^2\sum_{i=0}^{k-1}\frac{1}{3^i}
\end{align*}

Donde $k=\lfloor \log_3 n \rfloor$. Ahora, expandiendo el segundo sumando:

\begin{align*}
	n^2\sum_{i=0}^{k-1}\frac{1}{3^i} &= \frac{1-\frac{1}{3^k}}{1-\frac{1}{3}} \\
	&=\frac{3n^2}{2}(1-\frac{1}{n})\\
	&=\frac{3}{2}n^2-\frac{3}{2}n
\end{align*}

El cual es $\Theta(n^3)$, por lo que, por el teorema maestro 3° caso, $3f(\frac{9}{3})<\frac{f(9)}{2} \Leftrightarrow 27 < 108$, queda en $\Theta(n^2)$.

\item \textbf{[6 puntos]}Determine qué realiza el siguiente algoritmo, demuestre que es correcto y determine su complejidad asintótica.

\begin{scriptsize}
\begin{verbatim}
int F(int* A, int n, float x){
  p = 0;
  for i = 0 to n {
    p = A[n-i] + x * p;
  }
  return p;
}
\end{verbatim}
\end{scriptsize}

\textit{Indicación:} El arreglo $A$ de tamaño $n+1$ representa los coeficientes de un polinomio $p(x)=\sum_{i=0}^na_ix^i$.

\textbf{Respuesta} El algoritmo calcula el polinomio de grado $n$, cuyos coeficientes, como se indica arriba, se encuentran en el arreglo $A$. Además tiene una complejidad $O(n)$ ya que depende del largo $n+1$ del arreglo $A$ sobre el cual se está iterando.

\textbf{Demostración} Simplemente expandimos el loop:

\begin{itemize}
	\item $p_0$ = $A_n + x * 0$ \textit{Equivalente a un polinomio grado 0}
	\item $p_1$ = $A_{n-1} + x * p_0$ = $x^0 * A_{n-1} + x^1 * A_n$ \textit{Equivalente a un polinomio de grado 1}
	\item $p_2$ = $A_{n-2} + x * p_1$ = $x^0 * A_{n-2} + x^1 * A_{n-1} + x^2 * A_n$ \textit{Equivalente a un polinomio de grado 2}
\end{itemize}

Así, nos damos cuenta de que para un arreglo $A$ de largo $n+1$ (polinomio de grado $n$), $\forall{} i \in [0, n]$, el elemento $i$-ésimo tiene la forma $A_{i}*x^i$, lo cual cumple con la definición del polinomio dada arriba.

\item \textbf{[7 puntos]} Considere un conjunto de puntos tridimensionales con coordenadas reales con signo. Reporte la distancia mínima entre dos puntos. Para ello utilizaremos la distancia euclidiana entre dos puntos. Dados dos puntos $p_1(x_1,y_1,z_1)$ y $p_2(x_2,y_2,z_2)$, el cálculo de la distancia euclidiana es la siguiente:

\begin{equation*}
    d_{p_1,p_2} = \sqrt{(x_2-x_1)^2+(y_2-y_1)^2+(z_2-z_1)^2}
\end{equation*}

\begin{enumerate}
    \item Escriba un pseudo código para un algoritmo secuencial que resuelva el problema.
    \item Diseñe un algoritmo basado en dividir para conquistar que resuelva el problema en escriba su pseudo código.
    \item Demuestre correctitud de sus algoritmo y realice los análisis de tiempo de ejecución.
\end{enumerate}


\item \textbf{[8 puntos]} Considerando el problema anterior, modifique los algoritmos propuestos para que reporte todos los pares de puntos cuya distancia sea menor o igual a una distancia $d$.

\begin{enumerate}
    \item Modifique los dos algoritmos propuestos para el problema anterior para que resuelvan esta nueva versión. Escriba los pseudocódigos para los nuevos problemas.
    \item Explique los cambios realizados a la hora de adaptar los algoritmos.
    \item Demuestre correctitud de sus algoritmo y realice los análisis de tiempo de ejecución.
    \item Implemente sus algoritmos usando C/C++ definiendo una función para cada uno.
    \item Realice análisis experimental para lo cual se pide que construya un gráfico que muestre como varían los tiempos de ejecución en nanosegundos variando el tamaño de la entrada ($n$).
\end{enumerate}

%\item{[1.5 puntos]} Considere un arreglo $A$ ordenado cuyo largo es infinito. El arreglo $A$ está ordenado y se sabe que los primeros $n$ elementos tienen un valor finito y los siguientes son valores tienen el valor infinito. Diseñe un algoritmo en $O(log(n))$ que permita determinar si un elemento $a$ se encuentra o no en $A$. Note que el valor de $n$ es desconocido. Además argumente la correctitud de su algoritmo.


%Idea: Dado un árbol de n vértices que represente un ordenamiento (tipo, el nodo hijo de la izq es menor y el de la derecha, mayor). Se dice\\

%Armar árbol cartesiano $T(n) = 2T(n/2)+n$.\\

%Tiling problem para un cubo de lado $n=2^k$, con $k\in\N$.

% \item{[15 puntos]} Se quiere construir un cubo de lado $n=2^k$ unidades, con $k\in\N$, utilizando sólo un tipo de pieza especial. Esta pieza especial consiste en un cubo de lado 2 unidades al que le falta una sola esquina. Un ingeniero asegura que es imposible a menos que esté permitido que haya un espacio cúbico vacío de lado 1 unidad. Diseñe un algoritmo que, dado el lado del cubo $n=2^k$ y la posición donde quedará el espacio vacío, determine una manera de juntar las piezas especiales para armar el cubo de $n^3-1$ unidades cuadradas.

%\item{[1.5 puntos]} Se desea resolver el problema de encontrar el elemento mayoritario en un arreglo $A$ de largo $n$ si es que existe. En caso de no existir el algoritmo debe retornar que no existe. Ejemplo, si $A = [1,2,1,3,1,2,1]$, con $n=7$ el elemento mayoritario es el 1 porque aparece 4 veces y $4 > 7/2$. Diseñe los algoritmos siguientes usando dividir para conquistar, impleméntelos, determine sus recurrencias y obtenga soluciones. Además construya un gráfico con los tiempos de ejecución incrementando el número el valor de $n$ en potencias de 2.

%\begin{enumerate}
%  \item Diseñe e implemente un algoritmo que sea $O(n^2)$.
%  \item Diseñe e implemente un algoritmo que sea $O(n\log(n)$.
%  \item Diseñe e implemente un algoritmo que sea $O(n)$.
%\end{enumerate}

%\input{cheatsheet}

\end{enumerate}

% ----------------------------------------------------------------
\end{document}
% ----------------------------------------------------------------
